# 이진 탐색

> 일단 순차 탐색을 복습해보면
>
> 정의: 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데니터를 하나씩 차례대로 확인하는 방법이다
>
> 시간 복잡도: O(n)

~~~python
def sequential_search(n,target,array):
	for i in range(n):
    if array[n] == target:
      return i+1
~~~

이진탐색은 **데이터를 반으로 쪼개면서 탐색하는 방식으로,** 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 특징이 있다. 

탐색할 배열은 반드시 **정렬되어 있어야 하**지만, 탐색 속도가 매우 빠르다. 

이진 탐색에서 위치를 나타나는 변수 3개를 사용한다. **시작점, 끝점, 그리고 중간점.**

찾을 데이터가 중간점에 있는 데이터인지 반복적으로 비교하면서 결과를 찾는다.

**시간 복잡도: O(logN)**

~~~python
def binary_search(array, target, start, end):
  if start>end: #탐색할 데이터가 없으면
    return None
  mid = (start+end) // 2 #중간점 인덱스 계산, 참고로 //으로 나머지 없이 나눠야
  if array[mid] == target: #찾을 데이터가 중간점에 있으면
    return mid
  elif target > array[mid]: #찾을 데이터가 중간점보다 크면
    return binart_search(array, target, mid, end) 
  else: #찾을 데이터가 중간점보다 작으면
    return binart_search(array, target, start, mid-1)
~~~

이진 탐색은 많은 곳에서 응용되고, 고난이도 문제에서는 다른 알고리즘과 함께 사용하기도 한다. 쉽다고 생각할 수 있지만, 정작 참고 소스가 없으면 상당히 어렵다(고 책에 적혀 있다.) 그래서 이 코드를 외우는 것이 좋다고 했다.

또한 이진 탐색은 코테에서도 단골로 나오는 문제라서 

> ***어째든 외우자***

특히! **탐색범위가 2000만을 넘을 때** 시간복잡도가 O(logN)인 이진탐색을 사용하는 것이 좋다. 

# 트리 자료구조

데이터 베이스의 내부는 대용량 데이터 처리에 적합한 **트리 자료구조**를 이용해 항상 데이터가 정렬되어 있고, 이진 탐색과 비슷한 방법을 통해 데이터를 빠르게 탐색할 수 있다. 그래서 트리 구조에 대해 간단하게 알아보자.

#### 트리 구조는 **노드와 노드의 연결**이다. 

노드는 정보의 단위, 또는 정보를 가지고 있는 개체로 이해할 수 있다.

트리 자료구조에서 몇 가지 특징이 있다. 

1. 보모 노드와 자식 노드가 있다.
2. 트리의 최상단 노드를 루트 노드라 한다.
3. 트리의 최하단 노드를 단말 노드라 한다.
4. 트리의 일부도 트리이며, 이를 서브 트리라고 한다.
5. 트리는 파일 시스템과 같은 **계층적이고 정렬된 데이터에를 다루기에 적합하다**

트리 자료구조에서 이진 탐색과 비슷한 탐색 방법을 사용하려면 **이진 탐색 트리**가 필수다. 책에서는 그림을 통해 탐색과정을 매우 간단하게 설명했고, 스터디에서 굳이 하지 않아도 된다고 생각해 이 부분을 제외하겠습니다.  책의 P193~P195에 있습니다. 

### 빠르게 입력 받기

이진 탐색은 대부분 1000만 개의 데이터 중에서 탐색해야 한다. 만약 이 때 파일에 있는 데이터를 input()으로 하나씩 추가하면 시간초과로 오답 판정 받을 수 있다. 그래서 이 때는

#### sys라이브러리에 있는 readline() 함수를 사용하는 것이 좋다

~~~ python
import sys
input_data = sys.stdin.readline().rsplit()
#rsplit()는 엔터를 제거할 수 있음.
~~~

